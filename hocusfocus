#!/usr/bin/env ruby
require 'json'
require 'fileutils'
require 'time'
require 'date'
require 'open3'
require 'colorize'
require 'tty-prompt'

BASE_DIR = File.expand_path("~/.hocusfocus")
SESSIONS_DIR = File.join(BASE_DIR, "sessions")
STATS_DIR = File.join(BASE_DIR, "stats")
FileUtils.mkdir_p([SESSIONS_DIR, STATS_DIR])

prompt = TTY::Prompt.new

# --- utilities ---

def notify(message)
  system("notify-send", " HocusFocus", message)
end

def next_session_file
  existing = Dir[File.join(SESSIONS_DIR, "*.json")].map { |f| f[/(\d+)\.json$/, 1].to_i }
  next_num = (existing.max || 0) + 1
  File.join(SESSIONS_DIR, "#{next_num}.json")
end

def latest_session_file
  Dir[File.join(SESSIONS_DIR, "*.json")].sort_by { |f| f[/(\d+)\.json$/, 1].to_i }.last
end

def load_latest_session
  file = latest_session_file
  return nil unless file
  JSON.parse(File.read(file))
rescue
  nil
end

def save_session(file, data)
  File.write(file, JSON.pretty_generate(data))
end

def start_new_session(task)
  session = {
    "task" => task,
    "start" => Time.now.iso8601,
    "stop" => nil
  }
  file = next_session_file
  save_session(file, session)
  time_str = Time.now.strftime("%H:%M:%S")
  puts "→ Started #{task.colorize(:cyan)} at #{time_str}."
  notify("Started #{task} at #{time_str}")
end

def stop_session(file, session)
  session["stop"] = Time.now.iso8601
  save_session(file, session)
  time_str = Time.now.strftime("%H:%M:%S")
  puts "→ Stopped #{session["task"].colorize(:red)} at #{time_str}."
  notify("Stopped #{session["task"]} at #{time_str}")
end

# --- data analysis ---

def load_sessions
  Dir[File.join(SESSIONS_DIR, "*.json")].map do |f|
    data = JSON.parse(File.read(f))
    start_time = Time.parse(data["start"])
    stop_time = data["stop"] ? Time.parse(data["stop"]) : Time.now
    duration = stop_time - start_time
    data.merge("start_time" => start_time, "stop_time" => stop_time, "duration" => duration)
  rescue
    nil
  end.compact
end

def filter_sessions(sessions, timeframe)
  now = Time.now
  sessions.select do |s|
    case timeframe
    when :today
      s["start_time"].to_date == now.to_date
    when :week
      s["start_time"].cweek == now.cweek && s["start_time"].year == now.year
    when :month
      s["start_time"].month == now.month && s["start_time"].year == now.year
    when :year
      s["start_time"].year == now.year
    else
      true
    end
  end
end

def analyze_data(sessions)
  totals = Hash.new(0)
  sessions.each { |s| totals[s["task"]] += s["duration"] }
  grand_total = totals.values.sum
  percentages = totals.transform_values { |v| ((v / grand_total) * 100).round(2) rescue 0 }
  [totals, percentages, grand_total]
end

def format_duration(seconds)
  hours = (seconds / 3600).floor
  minutes = ((seconds % 3600) / 60).floor
  format("%02dh %02dm", hours, minutes)
end

def print_report(totals, percentages, grand_total)
  puts "\n===   HocusFocus Productivity Report ==="
  totals.each do |task, secs|
    color = case task
            when "WORK" then :green
            when "RECORD" then :yellow
            when "WASTE" then :light_black
            else :white
            end
    puts "#{task.ljust(8).colorize(color)}  #{format_duration(secs)}  (#{percentages[task]}%)"
  end
  puts "------------------------------------------"
  puts "Total: #{format_duration(grand_total)}".colorize(:light_blue)
end

def render_bar_chart(totals)
  data = totals.map { |k, v| "\"#{k}\" #{(v / 3600.0).round(2)}" }.join("\n")
  file = File.join(STATS_DIR, "bar_#{Time.now.to_i}.png")
  Open3.popen3("gnuplot") do |stdin, _, _, _|
    stdin.puts <<~GNUPLOT
      set terminal png size 600,400
      set output "#{file}"
      set title "Total Hours per Task"
      set style data histograms
      set style fill solid
      set ylabel "Hours"
      plot '-' using 2:xtic(1) title "Hours"
      #{data}
      e
    GNUPLOT
  end
  puts " Bar chart saved to #{file}"
end

# --- main ---

if ARGV.first == "data"
  sessions = load_sessions
  timeframe = prompt.select("Choose timeframe:", [
    {name: "Today", value: :today},
    {name: "This Week", value: :week},
    {name: "This Month", value: :month},
    {name: "This Year", value: :year},
    {name: "Lifetime", value: :lifetime}
  ])

  filtered = filter_sessions(sessions, timeframe)

  if filtered.empty?
    puts "No sessions found for that timeframe.".colorize(:red)
    exit
  end

  totals, percentages, grand_total = analyze_data(filtered)
  print_report(totals, percentages, grand_total)

  if prompt.yes?("Generate charts?")
    render_bar_chart(totals)
  end

  exit
end

# --- normal tracker flow ---
session = latest_session_file && load_latest_session

if ARGV.first == "stop"
  stop_session(latest_session_file, session)
  exit
end

if session && session["stop"].nil?
  start_time = Time.parse(session["start"])
  puts "You're currently doing #{session["task"].colorize(:cyan)} since #{start_time.strftime("%H:%M")}."
  action = prompt.select("What would you like to do?", [
    "Switch task",
    "Stop",
    "Cancel"
  ])

  case action
  when "Switch task"
    stop_session(latest_session_file, session)
    new_task = prompt.select("Choose a new task:", %w[WORK RECORD WASTE])
    start_new_session(new_task)
  when "Stop"
    stop_session(latest_session_file, session)
  else
    puts "Cancelled.".colorize(:light_black)
  end
else
  task = prompt.select("What are you doing?", %w[WORK RECORD WASTE])
  start_new_session(task)
end
